<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Cybersecurity Voice Agent</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .container {
            max-width: 700px;
            width: 100%;
            text-align: center;
        }

        .title {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
            animation: fadeIn 0.8s ease;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #a0aec0;
            margin-bottom: 2rem;
            animation: fadeIn 0.8s ease 0.2s backwards;
        }

        .permission-notice {
            background: rgba(237, 137, 54, 0.2);
            border: 1px solid rgba(237, 137, 54, 0.4);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 2rem;
            color: #f6ad55;
            font-size: 0.9rem;
            display: none;
        }

        .permission-notice.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .agent-status {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            animation: fadeIn 0.8s ease 0.4s backwards;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #48bb78;
            animation: pulse 2s infinite;
        }

        .status-dot.listening {
            background: #f56565;
        }

        .status-dot.thinking {
            background: #ed8936;
        }

        .talk-button {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.4);
            margin: 0 auto 1.5rem;
            display: block;
        }

        .talk-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 15px 50px rgba(102, 126, 234, 0.6);
        }

        .talk-button:active:not(:disabled) {
            transform: scale(0.98);
        }

        .talk-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .talk-button.listening {
            background: linear-gradient(135deg, #f56565 0%, #ed8936 100%);
            animation: pulseButton 1.5s infinite;
        }

        .talk-button.thinking {
            background: linear-gradient(135deg, #ed8936 0%, #f6ad55 100%);
        }

        .mic-icon {
            font-size: 3rem;
        }

        .input-method {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1rem;
        }

        .method-btn {
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.3);
            color: #667eea;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .method-btn.active {
            background: rgba(102, 126, 234, 0.4);
            border-color: #667eea;
        }

        .method-btn:hover {
            background: rgba(102, 126, 234, 0.3);
        }

        .text-input-container {
            display: none;
            margin-top: 1rem;
        }

        .text-input-container.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .text-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            padding: 1rem;
            color: white;
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .text-input::placeholder {
            color: #a0aec0;
        }

        .send-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 0.8rem 2rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .transcript-container {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 15px;
            padding: 1.5rem;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 2rem;
            text-align: left;
            display: none;
        }

        .transcript-container.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .message {
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 10px;
            animation: slideIn 0.3s ease;
        }

        .message.user {
            background: rgba(102, 126, 234, 0.2);
            border-left: 3px solid #667eea;
        }

        .message.agent {
            background: rgba(72, 187, 120, 0.2);
            border-left: 3px solid #48bb78;
        }

        .message-label {
            font-size: 0.8rem;
            color: #a0aec0;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .message-text {
            color: #cbd5e0;
            line-height: 1.6;
        }

        .capabilities {
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            animation: fadeIn 0.8s ease 0.6s backwards;
        }

        .capabilities h3 {
            color: #667eea;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .capabilities ul {
            list-style: none;
            color: #cbd5e0;
            text-align: left;
        }

        .capabilities li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
        }

        .capabilities li:before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #48bb78;
            font-weight: bold;
        }

        .error-message {
            background: rgba(245, 101, 101, 0.2);
            border: 1px solid rgba(245, 101, 101, 0.3);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            color: #f56565;
            display: none;
        }

        .error-message.active {
            display: block;
            animation: shake 0.5s ease;
        }

        .back-link {
            position: fixed;
            top: 2rem;
            left: 2rem;
            color: #667eea;
            text-decoration: none;
            font-size: 1rem;
            transition: color 0.3s ease;
        }

        .back-link:hover {
            color: #764ba2;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        @keyframes pulseButton {
            0%, 100% {
                box-shadow: 0 10px 40px rgba(245, 101, 101, 0.4);
            }
            50% {
                box-shadow: 0 15px 50px rgba(245, 101, 101, 0.8);
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
    </style>
</head>
<body>
    <a href="7dayai.html" class="back-link">‚Üê Back to Portfolio</a>

    <div class="container">
        <h1 class="title">AI Cybersecurity Assistant</h1>
        <p class="subtitle">Ask me anything about cybersecurity, GRC, or AI governance</p>

        <div class="permission-notice" id="permissionNotice">
            ‚ö†Ô∏è Microphone access required. Please allow when prompted, or use text input below.
        </div>

        <div class="agent-status">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Ready to talk</span>
            </div>

            <div class="input-method">
                <button class="method-btn active" id="voiceBtn" onclick="switchMode('voice')">üéôÔ∏è Voice</button>
                <button class="method-btn" id="textBtn" onclick="switchMode('text')">‚å®Ô∏è Type</button>
            </div>

            <div id="voiceMode">
                <button class="talk-button" id="talkButton">
                    <span class="mic-icon" id="micIcon">üéôÔ∏è</span>
                </button>
                <p style="color: #a0aec0; font-size: 0.9rem;">Click once to start, click again to end conversation</p>
            </div>

            <div class="text-input-container" id="textMode">
                <input type="text" class="text-input" id="textInput" placeholder="Type your cybersecurity question here...">
                <button class="send-btn" onclick="sendTextMessage()">Send Message</button>
            </div>
        </div>

        <div class="error-message" id="errorMessage"></div>

        <div class="transcript-container" id="transcriptContainer"></div>

        <div class="capabilities">
            <h3>I can help you with:</h3>
            <ul>
                <li>Cybersecurity threats and risk management</li>
                <li>GRC frameworks (SOC 2, NIST, ISO 27001)</li>
                <li>AI security and governance best practices</li>
                <li>Third-party risk management (TPRM)</li>
                <li>Compliance and audit preparation</li>
                <li>Security controls and implementations</li>
            </ul>
        </div>
    </div>

    <script>
        const talkButton = document.getElementById('talkButton');
        const micIcon = document.getElementById('micIcon');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const transcriptContainer = document.getElementById('transcriptContainer');
        const errorMessage = document.getElementById('errorMessage');
        const permissionNotice = document.getElementById('permissionNotice');
        const textInput = document.getElementById('textInput');

        let recognition = null;
        let isListening = false;
        let conversationHistory = [];
        let currentMode = 'voice';
        let isSpeaking = false;
        let currentUtterance = null;
        let continuousMode = false;

        function switchMode(mode) {
            currentMode = mode;
            const voiceBtn = document.getElementById('voiceBtn');
            const textBtn = document.getElementById('textBtn');
            const voiceMode = document.getElementById('voiceMode');
            const textMode = document.getElementById('textMode');

            if (mode === 'voice') {
                voiceBtn.classList.add('active');
                textBtn.classList.remove('active');
                voiceMode.style.display = 'block';
                textMode.classList.remove('active');
                initSpeechRecognition();
            } else {
                textBtn.classList.add('active');
                voiceBtn.classList.remove('active');
                voiceMode.style.display = 'none';
                textMode.classList.add('active');
            }
        }

        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = true; // Keep listening continuously
                recognition.interimResults = true; // Get interim results for interruption detection
                recognition.lang = 'en-US';

                recognition.onstart = () => {
                    isListening = true;
                    continuousMode = true;
                    talkButton.classList.add('listening');
                    statusDot.classList.add('listening');
                    statusText.textContent = 'Listening continuously...';
                    micIcon.textContent = 'üî¥';
                    permissionNotice.classList.remove('active');
                };

                recognition.onresult = async (event) => {
                    const lastResultIndex = event.results.length - 1;
                    const transcript = event.results[lastResultIndex][0].transcript.toLowerCase().trim();
                    
                    // Check for stop/interrupt commands
                    if (isSpeaking && (
                        transcript.includes('stop') || 
                        transcript.includes('wait') ||
                        transcript.includes('hold on') ||
                        transcript.includes('pause') ||
                        transcript.includes('quiet')
                    )) {
                        window.speechSynthesis.cancel();
                        isSpeaking = false;
                        statusText.textContent = 'Listening continuously...';
                        return; // Don't process these as questions
                    }

                    // Only process final results (not interim)
                    if (event.results[lastResultIndex].isFinal) {
                        // Filter out command-only phrases
                        if (shouldIgnorePhrase(transcript)) {
                            return;
                        }

                        addMessage('user', event.results[lastResultIndex][0].transcript);
                        await getAIResponse(event.results[lastResultIndex][0].transcript);
                    }
                };

                recognition.onerror = (event) => {
                    if (event.error === 'not-allowed') {
                        permissionNotice.classList.add('active');
                        showError('Microphone access denied. Please enable microphone in browser settings or use text input.');
                        continuousMode = false;
                    } else if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        showError(`Error: ${event.error}. Please try again or use text input.`);
                    }
                };

                recognition.onend = () => {
                    // Auto-restart if in continuous mode
                    if (continuousMode && !isSpeaking) {
                        try {
                            recognition.start();
                        } catch (e) {
                            // Already started, ignore
                        }
                    } else if (!continuousMode) {
                        resetButton();
                    }
                };
            } else {
                showError('Speech recognition not supported. Using text input mode.');
                switchMode('text');
            }
        }

        function shouldIgnorePhrase(transcript) {
            const ignorePatterns = [
                /^(stop|wait|hold on|pause|quiet|shh|hmm|um|uh)$/i,
                /^(okay|ok|yeah|yes|no|nope)$/i,
                /^(hey|hello|hi)$/i
            ];
            
            return ignorePatterns.some(pattern => pattern.test(transcript));
        }

        talkButton.addEventListener('click', () => {
            // Stop everything if clicking to end conversation
            if (continuousMode) {
                continuousMode = false;
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                }
                if (recognition) {
                    recognition.stop();
                }
                isSpeaking = false;
                isListening = false;
                resetButton();
                statusText.textContent = 'Conversation ended. Click to start again.';
                return;
            }

            if (!recognition) {
                initSpeechRecognition();
            }
            
            if (!recognition) {
                switchMode('text');
                return;
            }

            try {
                recognition.start();
                transcriptContainer.classList.add('active');
            } catch (error) {
                if (error.message.includes('already started')) {
                    // Already running, ignore
                } else {
                    showError('Could not start microphone. Using text input.');
                    switchMode('text');
                }
            }
        });

        textInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendTextMessage();
            }
        });

        async function sendTextMessage() {
            const message = textInput.value.trim();
            if (!message) return;

            textInput.value = '';
            addMessage('user', message);
            transcriptContainer.classList.add('active');
            await getAIResponse(message);
        }

        async function getAIResponse(userMessage) {
            statusDot.classList.remove('listening');
            statusDot.classList.add('thinking');
            statusText.textContent = 'Thinking...';
            if (currentMode === 'voice') {
                talkButton.classList.remove('listening');
                talkButton.classList.add('thinking');
                micIcon.textContent = '‚è≥';
            }

            // Stop any ongoing speech
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }

            try {
                const aiResponse = generateIntelligentResponse(userMessage);

                conversationHistory.push(
                    { role: 'user', content: userMessage },
                    { role: 'assistant', content: aiResponse }
                );

                addMessage('agent', aiResponse);
                
                if (currentMode === 'voice') {
                    speakResponse(aiResponse);
                }

            } catch (error) {
                showError('Something went wrong. Please try again.');
                console.error('Error:', error);
            }

            resetButton();
        }

        function generateIntelligentResponse(question) {
            const q = question.toLowerCase().trim();
            const lastUserMessage = conversationHistory.length > 1 ? 
                conversationHistory[conversationHistory.length - 2].content.toLowerCase() : '';
            
            // Handle conversational commands and phrases
            if (q === 'stop' || q === 'wait' || q === 'hold on' || q === 'pause') {
                return "Sure, take your time. I'm ready when you are.";
            }
            
            if (q === 'thank you' || q === 'thanks' || q === 'got it') {
                return "You're welcome! Feel free to ask if you have more questions.";
            }
            
            if (q === 'hello' || q === 'hi' || q === 'hey') {
                return "Hello! I'm here to help with cybersecurity and GRC questions. What would you like to know?";
            }

            // Check if question is out of scope
            const cybersecurityKeywords = [
                'security', 'cyber', 'hack', 'risk', 'compliance', 'grc', 'governance',
                'audit', 'control', 'threat', 'vulnerability', 'encryption', 'authentication',
                'firewall', 'malware', 'phishing', 'ransomware', 'breach', 'incident',
                'nist', 'iso', 'soc', 'gdpr', 'hipaa', 'pci', 'policy', 'framework',
                'ai security', 'data protection', 'privacy', 'pen test', 'vulnerability',
                'zero trust', 'access control', 'identity', 'tprm', 'vendor', 'third party',
                'attack', 'defense', 'secure', 'protect', 'monitor', 'detect', 'respond'
            ];
            
            const isRelevant = cybersecurityKeywords.some(keyword => q.includes(keyword)) ||
                             q.includes('what is') || q.includes('how do') || q.includes('can you explain');
            
            if (!isRelevant && q.length > 8) {
                return "I focus on cybersecurity and GRC topics. I'd be happy to discuss security frameworks, compliance, risk management, or threat prevention. What cybersecurity question can I help with?";
            }

            // Handle follow-up questions intelligently
            if ((q.includes('more') || q.includes('else') || q.includes('also') || q.includes('additionally')) && 
                lastUserMessage.length > 0) {
                // Provide additional context based on last topic
                if (lastUserMessage.includes('soc 2')) {
                    return "For SOC 2 success, engage stakeholders early, document everything thoroughly, conduct regular internal audits, and consider hiring an experienced consultant for your first audit. Common pitfalls include inadequate documentation, lack of segregation of duties, and insufficient change management processes.";
                }
                if (lastUserMessage.includes('ransomware')) {
                    return "Additionally, implement application whitelisting to prevent unauthorized software execution, enable ransomware detection in your EDR solution, restrict PowerShell and scripting tools, and maintain offline encrypted backups tested regularly. Consider cyber insurance but read the fine print carefully.";
                }
            }

            // GRC - Governance, Risk, and Compliance
            if (q.includes('grc')) {
                if (q.includes('implement') || q.includes('start') || q.includes('begin')) {
                    return "Start your GRC program by establishing a governance committee with executive sponsorship, conducting a risk assessment to identify key threats, documenting compliance requirements for your industry, and selecting a GRC platform for centralized management. Focus on quick wins that demonstrate value to gain organizational buy-in.";
                }
                if (q.includes('tool') || q.includes('software') || q.includes('platform')) {
                    return "Popular GRC platforms include ServiceNow GRC, RSA Archer, MetricStream, and LogicGate. For smaller organizations, consider Vanta, Drata, or Secureframe which automate compliance monitoring. Choose based on your compliance needs, budget, integration requirements, and whether you need workflow automation.";
                }
                return "GRC integrates Governance for strategic direction and accountability, Risk management to identify and mitigate threats, and Compliance to meet regulatory requirements. It creates a unified framework aligning security with business objectives, improving decision-making, and demonstrating due diligence to stakeholders.";
            }
            
            // SOC 2
            if (q.includes('soc 2') || q.includes('soc2')) {
                if (q.includes('difference') || q.includes('type 1') || q.includes('type 2')) {
                    return "Type 1 examines control design at a single point in time, like a snapshot. Type 2 tests controls over 6-12 months, proving they work consistently. Most customers prefer Type 2 as it demonstrates ongoing commitment to security. Start with Type 1 if you need faster results.";
                }
                if (q.includes('cost') || q.includes('price') || q.includes('expensive')) {
                    return "SOC 2 audits typically cost between 20 to 100 thousand dollars depending on organization size, complexity, and scope. Factor in additional costs for remediation, consultant fees, and ongoing monitoring. The investment pays off through customer trust, competitive advantage, and reduced security incidents.";
                }
                if (q.includes('prepare') || q.includes('ready')) {
                    return "Preparation takes 3-6 months typically. Start with gap analysis, implement missing controls, document policies and procedures, train your team, and run internal audits. Most organizations aren't ready on first attempt, so build in time for remediation.";
                }
                return "SOC 2 evaluates service organizations using Trust Service Criteria: Security is mandatory, while Availability, Processing Integrity, Confidentiality, and Privacy are optional based on your services. It's the gold standard for SaaS companies demonstrating they protect customer data.";
            }

            // NIST AI RMF
            if (q.includes('nist') && (q.includes('ai') || q.includes('rmf') || q.includes('artificial'))) {
                if (q.includes('implement') || q.includes('apply') || q.includes('use')) {
                    return "Apply NIST AI RMF by first establishing governance with clear AI oversight roles, then mapping your AI systems and their risks, measuring performance and impacts using metrics, and managing risks through controls. It's iterative, not linear, so expect continuous improvement cycles.";
                }
                return "NIST AI RMF provides a voluntary framework for managing AI risks using four functions: GOVERN establishes policies and accountability, MAP identifies AI context and risks, MEASURE tracks metrics and impacts, MANAGE implements and monitors controls. It's technology-neutral and risk-based.";
            }

            // ISO 27001
            if (q.includes('iso 27001') || q.includes('iso27001')) {
                if (q.includes('annex') || q.includes('controls')) {
                    return "ISO 27001 Annex A contains 93 security controls across 4 domains: Organizational, People, Physical, and Technological. You select applicable controls based on your risk assessment, not implement all 93. Common controls include access management, encryption, backup, and incident response.";
                }
                if (q.includes('cost') || q.includes('expensive')) {
                    return "ISO 27001 certification costs vary widely from 15 to 100 thousand dollars based on organization size and scope. Budget for consultant fees, implementation costs, internal resources, and annual surveillance audits. Recertification occurs every 3 years.";
                }
                return "ISO 27001 defines requirements for establishing, implementing, and maintaining an Information Security Management System. It demonstrates systematic risk management and commitment to information security. Certification requires external audit and provides competitive advantage globally.";
            }

            // Add all the other topic responses from before...
            if (q.includes('tprm') || q.includes('third party risk') || q.includes('vendor risk')) {
                return "Assess third-party risk through due diligence questionnaires, requesting SOC 2 or ISO 27001 reports, evaluating financial stability, checking references, defining SLAs with security requirements, and continuous monitoring. Categorize vendors by risk level and adjust scrutiny accordingly.";
            }

            if (q.includes('ransomware')) {
                if (q.includes('attacked') || q.includes('hit') || q.includes('encrypted')) {
                    return "If hit by ransomware: immediately isolate affected systems, don't pay the ransom, notify law enforcement and cyber insurance, activate your incident response plan, restore from clean backups, and conduct forensics to identify the entry point. Document everything for legal and compliance purposes.";
                }
                return "Defend against ransomware with offline backups tested regularly, endpoint detection and response, email filtering, security awareness training, network segmentation, patch management, and least privilege access. Consider backup immutability and air-gapped storage for critical data.";
            }

            if (q.includes('zero trust')) {
                return "Implement zero trust by verifying every access request regardless of location, enforcing least privilege, segmenting networks, requiring strong authentication, continuously monitoring behavior, and assuming breach. Start with high-value assets and expand gradually.";
            }

            if (q.includes('phishing')) {
                return "Combat phishing through regular training with simulated campaigns, advanced email filtering, DMARC, DKIM, and SPF protocols, multi-factor authentication, security awareness culture, and easy incident reporting. Train users to verify requests through alternate channels before taking action.";
            }

            // Continue with other topics... (keeping response concise)
            if (q.includes('incident response')) {
                return "Build incident response capability with defined roles, documented playbooks for common scenarios, 24/7 contact procedures, evidence collection processes, communication templates, and regular tabletop exercises. Establish relationships with forensics firms and legal counsel before you need them.";
            }

            if (q.includes('penetration test') || q.includes('pentest')) {
                return "Conduct pentests annually minimum, after major changes, and before launching new products. Define clear scope and rules of engagement, use qualified testers, remediate critical findings promptly, and retest after fixes. Consider red team exercises for mature programs.";
            }

            if (q.includes('mfa') || q.includes('multi-factor')) {
                return "Implement MFA for all remote access, privileged accounts, and sensitive systems. Use authenticator apps or hardware tokens rather than SMS when possible. Provide backup codes and account recovery procedures. MFA reduces breach risk by over 99 percent.";
            }

            // Default for unclear but relevant questions
            if (q.length < 10) {
                return "Could you provide more details about what you'd like to know? I can explain concepts, guide implementation, or discuss best practices for cybersecurity and GRC.";
            }

            return "That's a good question. For detailed guidance on that specific topic, I recommend consulting with a cybersecurity professional. I can help with general concepts, frameworks, and best practices. What specific aspect interests you?";
        }

        function speakResponse(text) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();
                
                currentUtterance = new SpeechSynthesisUtterance(text);
                currentUtterance.rate = 1.0;
                currentUtterance.pitch = 1.0;
                currentUtterance.volume = 1;
                
                currentUtterance.onstart = () => {
                    isSpeaking = true;
                    statusText.textContent = 'Speaking... (say "stop" to interrupt)';
                };

                currentUtterance.onend = () => {
                    isSpeaking = false;
                    statusText.textContent = 'Listening continuously...';
                    currentUtterance = null;
                };

                currentUtterance.onerror = () => {
                    isSpeaking = false;
                    statusText.textContent = 'Listening continuously...';
                };

                // Small delay to ensure speech cancellation completes
                setTimeout(() => {
                    window.speechSynthesis.speak(currentUtterance);
                }, 100);
            }
        }

        function addMessage(type, text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const label = document.createElement('div');
            label.className = 'message-label';
            label.textContent = type === 'user' ? 'You:' : 'AI Assistant:';
            
            const content = document.createElement('div');
            content.className = 'message-text';
            content.textContent = text;
            
            messageDiv.appendChild(label);
            messageDiv.appendChild(content);
            transcriptContainer.appendChild(messageDiv);
            
            transcriptContainer.scrollTop = transcriptContainer.scrollHeight;
        }

        function resetButton() {
            isListening = false;
            talkButton.classList.remove('listening', 'thinking');
            statusDot.classList.remove('listening', 'thinking');
            statusText.textContent = 'Ready to talk';
            micIcon.textContent = 'üéôÔ∏è';
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('active');
            setTimeout(() => {
                errorMessage.classList.remove('active');
            }, 5000);
        }

        // Initialize
        initSpeechRecognition();
    </script>
</body>
</html>